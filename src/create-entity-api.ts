import { createApi } from '@reduxjs/toolkit/query/react';
import { ClassConstructor, instanceToPlain, plainToInstance } from 'class-transformer';
import { omit, pickBy } from 'lodash';
import { EntityTagID } from './enums';
import { BaseEntity, EntityRequest, PaginationRequest, PaginationResponse } from './models';
import { Pagination } from './models/pagination';
import { EntityApi, EntityApiCustomHooks, EntityEndpointName, EntityPartial } from './types';
import {
  BaseQueryFunction,
  createApiCreator,
  createEntityApiHooks,
  createEntityApiUtils,
  createEntityInstance,
  prepareRequestParams
} from './utils';

/**
 * Creates an entity API with specified options.
 *
 * @template TEntity - The entity model class constructor.
 * @template TSearchRequest - The search request class constructor. Defaults to PaginationRequest.
 * @template TEntityRequest - The get request class constructor. Defaults to EntityRequest.
 * @template TSearchResponse - The search response class constructor. Defaults to PaginationResponse.
 * @template TOmitEndpoints - The array of endpoint names to omit(from predefined endpoints). Defaults to never.
 * @param {Object} options - The options object.
 * @param {string} options.entityName - An entity name. Must be unique.
 * @param {string} options.baseEndpoint - Endpoint, relative to base URL configured in the API creator.
 * @param {ReturnType<typeof createApiCreator> | undefined} [options.baseApiCreator] - The APIs creator generated by `createApiCreator` that shares configuration for new APIs.
 * @param {BaseQueryFunction | undefined} [options.baseQuery] - The base query function.
 * @param {ClassConstructor<TEntity>} options.entityConstructor - The entity model class constructor.
 * @param {ClassConstructor<TSearchRequest> | typeof PaginationRequest} [options.entitySearchRequestConstructor] - The search request class constructor. Defaults to PaginationRequest.
 * @param {ClassConstructor<TEntityRequest> | typeof EntityRequest} [options.entityGetRequestConstructor] - The get request class constructor. Defaults to EntityRequest.
 * @param {ClassConstructor<TSearchResponse> | typeof PaginationResponse} [options.entitySearchResponseConstructor] - The search response class constructor. Defaults to PaginationResponse.
 * @param {Array<EntityEndpointName>} [options.omitEndpoints] - The array of endpoints to omit. Defaults to never.
 * @param {((item: TEntity) => string | number) | undefined} [options.getEntityId] - The function to get entity id. Defaults to ((item) => item.id).
 * @param {((pagination: Pagination, request: TSearchRequest) => number) | undefined} [options.getCurrentPage] - The function to get current page. Defaults to ((pagination) => pagination.currentPage).
 * @returns {Omit<EntityApi<TEntity, TSearchRequest, TEntityRequest, TSearchResponse, typeof omitEndpoints>, keyof EntityApiCustomHooks> & EntityApiCustomHooks<TEntity, TSearchRequest, TSearchResponse>} The entity API.
 */
export function createEntityApi<
  TEntity extends BaseEntity,
  TSearchRequest extends PaginationRequest = PaginationRequest,
  TEntityRequest extends EntityRequest = EntityRequest,
  TSearchResponse extends PaginationResponse<TEntity> = PaginationResponse<TEntity>,
  TOmitEndpoints extends Readonly<Array<EntityEndpointName>> = never,
>({
  omitEndpoints,
  ...options
}: {
  entityName: string;
  baseEndpoint: string;
  baseApiCreator?: ReturnType<typeof createApiCreator>;
  baseQuery?: BaseQueryFunction;
  entityConstructor: ClassConstructor<TEntity>;
  entitySearchRequestConstructor?: ClassConstructor<TSearchRequest>;
  entityGetRequestConstructor?: ClassConstructor<TEntityRequest>;
  entitySearchResponseConstructor?: ClassConstructor<TSearchResponse>;
  omitEndpoints?: TOmitEndpoints;
  getEntityId?: (entity: TEntity) => string | number;
  getCurrentPage?: (pagination: Pagination, request: TSearchRequest) => number;
}): Omit<
  EntityApi<TEntity, TSearchRequest, TEntityRequest, TSearchResponse, typeof omitEndpoints>,
  keyof EntityApiCustomHooks
> &
  EntityApiCustomHooks<TEntity, TSearchRequest, TSearchResponse> {
  const {
    entityName,
    baseEndpoint,
    baseApiCreator,
    baseQuery,
    entityConstructor,
    entitySearchRequestConstructor = PaginationRequest,
    entityGetRequestConstructor = EntityRequest,
    entitySearchResponseConstructor = PaginationResponse,
    getEntityId = (item) => item.id,
    getCurrentPage = (pagination) => pagination.currentPage
  } = options;

  if (!baseQuery && !baseApiCreator) {
    throw new Error('Passing "baseQuery" or "baseApiCreator" is required in when using "createEntityAPI"!');
  }

  const initApi = (baseApiCreator as typeof createApi) || createApi;

  const api = initApi({
    reducerPath: entityName,
    baseQuery: baseQuery as BaseQueryFunction,
    tagTypes: [entityName, EntityTagID.LIST],
    endpoints: (builder) => {
      const endpoints = {
        /**
         * Creates a mutation endpoint that performs a `POST /{baseEndpoint}` request to create an entity using `entityConstructor` class constructor defined in `createEntityApi` options.
         * Accepts Partial data of entity instance.
         *
         * @method create
         * @param {Partial<TEntity>} params - The parameters for creating the entity.
         * @return {Promise<TEntity>} A promise that resolves to the created entity.
         */
        create: builder.mutation<TEntity, Partial<TEntity>>({
          query: (params) => {
            let formattedParams;

            if (params instanceof FormData) {
              formattedParams = params;
            } else {
              const request = createEntityInstance(entityConstructor, params, { fromInstancePartial: true });
              const files = pickBy(params, (value) => value instanceof File);

              formattedParams = {
                ...instanceToPlain(request),
                ...files
              };
            }

            return {
              method: 'post',
              url: baseEndpoint,
              data: formattedParams
            };
          },
          transformResponse: (response: object) => createEntityInstance<TEntity>(entityConstructor, response)
        }),

        /**
         * Creates a query endpoint that requests `GET /{baseEndpoint}` for searching entities.
         * Accepts request params described by `PaginationRequest` and returns `PaginationResponse`.
         * Both classes can be extended to define your onw structure using `entitySearchRequestConstructor` and `entitySearchResponseConstructor` in `createEntityApi`.
         *
         * @param {TSearchRequest} params - The parameters for searching the entities.
         * @return {Promise<TSearchResponse>} A promise that resolves to the search result.
         */
        search: builder.query<TSearchResponse, TSearchRequest>({
          query: (params) => {
            return {
              method: 'get',
              url: baseEndpoint,
              params: prepareRequestParams(params, entitySearchRequestConstructor)
            };
          },
          serializeQueryArgs: ({ queryArgs }) => prepareRequestParams(queryArgs, entitySearchRequestConstructor),
          transformResponse: (response) => {
            const { data, pagination } = plainToInstance(entitySearchResponseConstructor, response);

            return {
              pagination,
              data: data.map((item) => createEntityInstance<TEntity>(entityConstructor, item))
            } as TSearchResponse;
          },
          providesTags: (result) => result?.data
              ? [
                  { type: entityName, id: EntityTagID.LIST },
                  ...result.data.map((item) => ({ type: entityName, id: getEntityId(item) }))
                ]
              : [entityName]
        }),

        /**
         * Creates a query endpoint for infinite searching entities. Behaves similar to `search`, but accumulates data from newly requested pages.
         * This query can be used with `useSearchInfiniteQuery` hook to implement infinite scrolling lists.
         * It supports loading data in both directions using `fetchNextPage` and `fetchPreviousPage` callbacks, and provides other useful props.
         *
         * @param {TSearchRequest} params - The parameters for searching the entities.
         * @return {Promise<(TSearchResponse & { minPage?: number })>} A promise that resolves to the search result.
         */
        searchInfinite: builder.query<TSearchResponse & { minPage?: number }, TSearchRequest>({
          query: (params) => {
            return {
              method: 'get',
              url: baseEndpoint,
              params: prepareRequestParams(params, entitySearchRequestConstructor)
            };
          },
          serializeQueryArgs: ({ queryArgs }) => {
            return prepareRequestParams(omit(queryArgs, ['page']) as TSearchRequest, entitySearchRequestConstructor);
          },
          forceRefetch: ({ currentArg, previousArg }) => currentArg?.page !== previousArg?.page,
          transformResponse: (response, _, request) => {
            const { data, pagination } = plainToInstance(entitySearchResponseConstructor, response);

            return {
              minPage: pagination.currentPage,
              data: data.map((item) => createEntityInstance<TEntity>(entityConstructor, item)),
              pagination: { ...pagination, currentPage: getCurrentPage(pagination, request) }
            } as TSearchResponse & { minPage?: number };
          },
          providesTags: (result) => result?.data
              ? [
                  { type: entityName, id: EntityTagID.LIST },
                  ...result.data.map((item) => ({ type: entityName, id: getEntityId(item) }))
                ]
              : [entityName],
          merge: (cache, response) => {
            if (
              response.pagination.currentPage === 1 &&
              cache.pagination.currentPage === response.pagination.currentPage
            ) {
              cache.data = response.data;
              cache.pagination = response.pagination;
            } else {
              const fetchedItemsIDs = response.data.map((item) => getEntityId(item));
              cache.data = cache.data.filter((item) => !fetchedItemsIDs.includes(getEntityId(item)));

              if (cache.minPage && response.pagination.currentPage <= cache.minPage) {
                cache.data.unshift(...response.data);
                cache.minPage = response.pagination.currentPage;
              } else {
                cache.data.push(...response.data);
                cache.pagination = response.pagination;
              }
            }
          }
        }),

        /**
         * Creates a query endpoint that requests `GET /{baseEndpoint}/{id}` to fetch single entity data by ID.
         * Can accept optional request params which implements `EntityRequest` instance.
         * Request shape can be extended by `entityGetRequestConstructor` property in createEntityApi.
         *
         * @param {Object} queryArgs - The query arguments.
         * @param {TEntity['id']} queryArgs.id - The ID of the entity to fetch.
         * @param {TEntityRequest} [queryArgs.params] - Optional additional parameters for the request.
         * @return {Promise<TEntity>} A promise that resolves to the fetched entity.
         */
        get: builder.query<TEntity, { id: TEntity['id']; params?: TEntityRequest }>({
          query: ({ id, params }) => {
            return {
              method: 'get',
              url: `${baseEndpoint}/${id}`,
              params: prepareRequestParams(params, entityGetRequestConstructor)
            };
          },
          serializeQueryArgs: ({ queryArgs: { id, params } }) => {
            const request = prepareRequestParams(params, entityGetRequestConstructor);

            return { id, params: request };
          },
          transformResponse: (response: object) => createEntityInstance<TEntity>(entityConstructor, response),
          providesTags: (result) => (result ? [{ type: entityName, id: result.id }] : [entityName])
        }),

        /**
         * Creates a mutation endpoint that performs `PUT /{baseEndpoint}/{id}` request to update entity data by ID.
         * Accepts Partial data of entity instance with mandatory id.
         * By default, successful call of update mutation for some entity will patch it's state in all queries where it presented.
         * No further refetch needed. State patch is done my simple merge existing data with updated one.
         *
         * @param {Object} params - The parameters for updating the entity.
         * @param {TEntity['id']} params.id - The ID of the entity to update.
         * @param {Partial<TEntity>} params.data - The partial data of the entity to update.
         * @return {Promise<EntityPartial<TEntity>>} A promise that resolves to the updated entity.
         */
        update: builder.mutation<EntityPartial<TEntity>, EntityPartial<TEntity>>({
          query: (params) => {
            const updatedEntity = createEntityInstance(entityConstructor, params, {
              fromInstancePartial: true
            }) as TEntity;
            const request = instanceToPlain(updatedEntity);

            return {
              method: 'put',
              url: `${baseEndpoint}/${request.id}`,
              data: request
            };
          },
          async onQueryStarted(arg, api) {
            await entityApiUtils.handleEntityUpdate(arg, api, { optimistic: false });
          },
          transformResponse: (response: object | undefined, _error, arg) => response
              ? createEntityInstance<TEntity>(entityConstructor, response)
              : (createEntityInstance(entityConstructor, arg, { fromInstancePartial: true }) as TEntity)
        }),

        /**
         * Creates a mutation endpoint that deletes entities by ID using `DELETE/{baseEndpoint}/{id}` request.
         * Accepts entity ID to delete. On success this mutation will remove the entity from all queries where it was presented without refetching them.
         *
         * @param {number} id - The ID of the entity to delete.
         * @return {Promise<void>} A promise that resolves to `undefined` upon successful deletion.
         */
        delete: builder.mutation<void, number>({
          query: (id) => ({
            method: 'delete',
            url: `${baseEndpoint}/${id}`
          }),
          async onQueryStarted(arg, api) {
            await entityApiUtils.handleEntityDelete(arg, api, { optimistic: false });
          }
        })
      };

      return omit(endpoints, omitEndpoints || []);
    }
  }) as unknown as EntityApi<TEntity, TSearchRequest, TEntityRequest, TSearchResponse>;

  // Extend api util
  const entityApiUtils = createEntityApiUtils({
    api,
    entityGetRequestConstructor,
    entitySearchRequestConstructor
  });
  Object.assign(api.util, entityApiUtils);

  // Extend api hooks
  const entityApiHooks = createEntityApiHooks(api);
  Object.assign(api, entityApiHooks);

  // TODO: Get rid of any below
  return api as any;
}
