import { createApi } from '@reduxjs/toolkit/query/react';
import { ClassConstructor, instanceToPlain, plainToInstance } from 'class-transformer';
import { omit, pickBy } from 'lodash';
import { EntityTagID } from './enums';
import { BaseEntity, EntityRequest, PaginationRequest, PaginationResponse } from './models';
import { Pagination } from './models/pagination';
import { EntityApi, EntityApiCustomHooks, EntityEndpointName, EntityPartial } from './types';
import {
  BaseQueryFunction,
  createApiCreator,
  createEntityApiHooks,
  createEntityApiUtils,
  createEntityInstance,
  getEntityTags,
  prepareRequestParams,
} from './utils';

/**
 * Creates an entity API with specified options.
 *
 * @template TEntity - The entity model class constructor.
 * @template TSearchRequest - The search request class constructor. Defaults to PaginationRequest.
 * @template TEntityRequest - The get request class constructor. Defaults to EntityRequest.
 * @template TSearchResponse - The search response class constructor. Defaults to PaginationResponse.
 * @template TOmitEndpoints - The array of endpoint names to omit(from predefined endpoints). Defaults to never.
 * @param {Object} options - The options object.
 * @param {string} options.entityName - An entity name. Must be unique.
 * @param {string} options.baseEndpoint - Endpoint, relative to base URL configured in the API creator.
 * @param {ReturnType<typeof createApiCreator> | undefined} [options.baseApiCreator] - The APIs creator generated by `createApiCreator` that shares configuration for new APIs.
 * @param {BaseQueryFunction | undefined} [options.baseQuery] - The base query function.
 * @param {ClassConstructor<TEntity>} options.entityConstructor - The entity model class constructor.
 * @param {ClassConstructor<TSearchRequest> | typeof PaginationRequest} [options.entitySearchRequestConstructor=PaginationRequest] - The search request class constructor.
 * @param {ClassConstructor<TEntityRequest> | typeof EntityRequest} [options.entityGetRequestConstructor=EntityRequest] - The get request class constructor.
 * @param {ClassConstructor<TSearchResponse> | typeof PaginationResponse} [options.entitySearchResponseConstructor=PaginationResponse] - The search response class constructor.
 * @param {Array<EntityEndpointName>} [options.omitEndpoints] - The array of endpoints to omit.
 * @param {((item: TEntity) => string | number) | undefined} [options.getEntityId=((item) => item.id)] - The function to get entity id.
 * @param {((pagination: Pagination, request: TSearchRequest) => number) | undefined} [options.getCurrentPage=((pagination) => pagination.currentPage)] - The function to get current page.
 * @returns {Omit<EntityApi<TEntity, TSearchRequest, TEntityRequest, TSearchResponse, typeof omitEndpoints>, keyof EntityApiCustomHooks> & EntityApiCustomHooks<TEntity, TSearchRequest, TSearchResponse>} The entity API.
 */
export function createEntityApi<
  TEntity extends BaseEntity,
  TSearchRequest extends PaginationRequest = PaginationRequest,
  TEntityRequest extends EntityRequest = EntityRequest,
  TSearchResponse extends PaginationResponse<TEntity> = PaginationResponse<TEntity>,
  TOmitEndpoints extends Readonly<Array<EntityEndpointName>> = never,
>({
  omitEndpoints,
  ...options
}: {
  /**
   * An entity name. Must be unique.
   */
  entityName: string;
  /**
   * Endpoint, relative to base URL configured in the API creator.
   */
  baseEndpoint: string;
  /**
   * The APIs creator generated by `createApiCreator` that shares configuration for new APIs.
   */
  baseApiCreator?: ReturnType<typeof createApiCreator>;
  /**
   * The base query function.
   */
  baseQuery?: BaseQueryFunction;
  /**
   * The entity model class constructor.
   */
  entityConstructor: ClassConstructor<TEntity>;
  /**
   * The search request class constructor. Defaults to PaginationRequest.
   */
  entitySearchRequestConstructor?: ClassConstructor<TSearchRequest>;
  /**
   * The get request class constructor. Defaults to EntityRequest.
   */
  entityGetRequestConstructor?: ClassConstructor<TEntityRequest>;
  /**
   * The search response class constructor. Defaults to PaginationResponse.
   */
  entitySearchResponseConstructor?: ClassConstructor<TSearchResponse>;
  /**
   * The array of endpoint names to omit(from predefined endpoints). Defaults to never.
   */
  omitEndpoints?: TOmitEndpoints;
  /**
   * A custom function to get entity id. By default entity 'id' field is used.
   */
  getEntityId?: (entity: TEntity) => string | number;
  /**
   * The function to get current page.
   */
  getCurrentPage?: (pagination: Pagination, request: TSearchRequest) => number;
}): Omit<
  EntityApi<TEntity, TSearchRequest, TEntityRequest, TSearchResponse, typeof omitEndpoints>,
  keyof EntityApiCustomHooks
> &
  EntityApiCustomHooks<TEntity, TSearchRequest, TSearchResponse> {
  const {
    entityName,
    baseEndpoint,
    baseApiCreator,
    baseQuery,
    entityConstructor,
    entitySearchRequestConstructor = PaginationRequest,
    entityGetRequestConstructor = EntityRequest,
    entitySearchResponseConstructor = PaginationResponse,
    getEntityId = (item) => item.id,
    getCurrentPage = (pagination) => pagination.currentPage,
  } = options;

  if (!baseQuery && !baseApiCreator) {
    throw new Error('Passing "baseQuery" or "baseApiCreator" is required in when using "createEntityAPI"!');
  }

  const initApi = (baseApiCreator as typeof createApi) || createApi;

  const api = initApi({
    reducerPath: entityName,
    baseQuery: baseQuery as BaseQueryFunction,
    tagTypes: [entityName, EntityTagID.LIST],
    endpoints: (builder) => {
      const endpoints = {
        /**
         * Creates a mutation endpoint that performs a `POST /{baseEndpoint}` request to create an entity using `entityConstructor` class constructor defined in `createEntityApi` options.
         *
         * @method create
         * @param {Partial<TEntity>} params - The parameters for creating the entity.
         * @return {Promise<TEntity>} A promise that resolves to the created entity.
         */
        create: builder.mutation<TEntity, Partial<TEntity>>({
          query: (params) => {
            let formattedParams;

            if (params instanceof FormData) {
              formattedParams = params;
            } else {
              const request = createEntityInstance(entityConstructor, params, { fromInstancePartial: true });
              const files = pickBy(params, (value) => value instanceof File);

              formattedParams = {
                ...instanceToPlain(request),
                ...files,
              };
            }

            return {
              method: 'post',
              url: baseEndpoint,
              data: formattedParams,
            };
          },
          transformResponse: (response: object) => createEntityInstance<TEntity>(entityConstructor, response),
        }),

        /**
         * Creates a query endpoint that requests `GET /{baseEndpoint}` for searching entities.
         * Accepts request params described by `entitySearchRequestConstructor` and returns `entitySearchResponseConstructor` extending `PaginationRequest` and `PaginationResponse` respectively.
         *
         * @param {TSearchRequest} params - The parameters for searching the entities.
         * @return {Promise<TSearchResponse>} A promise that resolves to the search result.
         */
        search: builder.query<TSearchResponse, TSearchRequest>({
          query: (params) => {
            return {
              method: 'get',
              url: baseEndpoint,
              params: prepareRequestParams(params, entitySearchRequestConstructor),
            };
          },
          serializeQueryArgs: ({ queryArgs }) => prepareRequestParams(queryArgs, entitySearchRequestConstructor),
          transformResponse: (response) => {
            const { data, pagination } = plainToInstance(entitySearchResponseConstructor, response);

            return {
              pagination,
              data: data.map((item) => createEntityInstance<TEntity>(entityConstructor, item)),
            } as TSearchResponse;
          },
          providesTags: (response) => getEntityTags(entityName, response, getEntityId),
        }),
        /**
         * Creates a query endpoint for infinite searching entities. Behaves similar to `search`:
         * - A query endpoint that requests `GET /{baseEndpoint}` for searching entities.
         * - Accepts request params described by `entitySearchRequestConstructor` and returns `entitySearchResponseConstructor` extending `PaginationRequest` and `PaginationResponse` respectively.
         * But accumulates data from newly requested pages.
         * This query can be used with `useSearchInfiniteQuery` hook to implement infinite scrolling lists.
         * It supports loading data in both directions using `fetchNextPage` and `fetchPreviousPage` callbacks, and provides other useful props.
         *
         * @param {TSearchRequest} params - The parameters for searching the entities.
         * @return {Promise<(TSearchResponse & { minPage?: number })>} A promise that resolves to the search result.
         */
        searchInfinite: builder.query<TSearchResponse & { minPage?: number }, TSearchRequest>({
          query: (params) => {
            return {
              method: 'get',
              url: baseEndpoint,
              params: prepareRequestParams(params, entitySearchRequestConstructor),
            };
          },
          serializeQueryArgs: ({ queryArgs }) => {
            return prepareRequestParams(omit(queryArgs, ['page']) as TSearchRequest, entitySearchRequestConstructor);
          },
          forceRefetch: ({ currentArg, previousArg }) => currentArg?.page !== previousArg?.page,
          transformResponse: (response, _, request) => {
            const { data, pagination } = plainToInstance(entitySearchResponseConstructor, response);

            return {
              minPage: pagination.currentPage,
              data: data.map((item) => createEntityInstance<TEntity>(entityConstructor, item)),
              pagination: { ...pagination, currentPage: getCurrentPage(pagination, request) },
            } as TSearchResponse & { minPage?: number };
          },
          providesTags: (response) => getEntityTags(entityName, response, getEntityId),
          merge: (cache, response) => {
            if (response.pagination.currentPage === 1) {
              cache.data = response.data;
              cache.pagination = response.pagination;
            } else {
              const fetchedItemsIDs = response.data.map((item) => getEntityId(item));
              cache.data = cache.data.filter((item) => !fetchedItemsIDs.includes(getEntityId(item)));

              if (cache.minPage && response.pagination.currentPage <= cache.minPage) {
                cache.data.unshift(...response.data);
                cache.minPage = response.pagination.currentPage;
              } else {
                cache.data.push(...response.data);
                cache.pagination = response.pagination;
              }
            }
          },
        }),
        /**
         * Creates a query endpoint for infinite searching entities.
         * - A query endpoint that requests `GET /{baseEndpoint}` for searching entities.
         * - Accepts request params described by `entitySearchRequestConstructor` and returns `entitySearchResponseConstructor` extending `PaginationRequest` and `PaginationResponse` respectively.
         * But accumulates data from newly requested pages.
         * This query can be used with `useSearchPaginatedInfiniteQuery` hook to implement infinite scrolling lists.
         * It supports loading data in both directions using `fetchNextPage` and `fetchPreviousPage` callbacks, and provides other useful props.
         *
         * @param {TSearchRequest} params - The parameters for searching the entities.
         * @return {Promise<InfiniteData<TSearchResponse, number>>} A promise that resolves to the search result.
         */
        searchPaginated: builder.infiniteQuery<TSearchResponse, TSearchRequest, number>({
          infiniteQueryOptions: {
            initialPageParam: 1,

            getNextPageParam: (lastPage, _allPages, lastPageParam) => lastPageParam < lastPage?.pagination.lastPage ? lastPageParam + 1 : undefined,
          },
          query: ({ queryArg, pageParam }) => {
            return {
              method: 'get',
              url: baseEndpoint,
              params: prepareRequestParams({ ...queryArg, page: pageParam }, entitySearchRequestConstructor),
            };
          },
          transformResponse: (response, _, { queryArg }) => {
            const { data, pagination } = plainToInstance(entitySearchResponseConstructor, response);

            return {
              data: data.map((item) => createEntityInstance<TEntity>(entityConstructor, item)),
              pagination: { ...pagination, currentPage: getCurrentPage(pagination, queryArg) },
            } as TSearchResponse;
          },
          providesTags: (data) => {
            return data
              ? [
                  { type: entityName, id: EntityTagID.LIST },
                  ...data.pages
                    .map((response) => response.data.map((item) => ({ type: entityName, id: getEntityId(item) })))
                    .flat(),
                ]
              : [];
          },
        }),

        /**
         * Creates a query endpoint that requests `GET /{baseEndpoint}/{id}` to fetch single entity data by ID.
         * Accepts request params described by `entityGetRequestConstructor`
         *
         * @param {Object} queryArgs - The query arguments.
         * @param {TEntity['id']} queryArgs.id - The ID of the entity to fetch.
         * @param {TEntityRequest} [queryArgs.params] - Optional additional parameters for the request.
         * @return {Promise<TEntity>} A promise that resolves to the fetched entity.
         */
        get: builder.query<TEntity, { id: TEntity['id']; params?: TEntityRequest }>({
          query: ({ id, params }) => {
            return {
              method: 'get',
              url: `${baseEndpoint}/${id}`,
              params: prepareRequestParams(params, entityGetRequestConstructor),
            };
          },
          serializeQueryArgs: ({ queryArgs: { id, params } }) => {
            const request = prepareRequestParams(params, entityGetRequestConstructor);

            return { id, params: request };
          },
          transformResponse: (response: object) => createEntityInstance<TEntity>(entityConstructor, response),
          providesTags: (response) => getEntityTags(entityName, response, getEntityId),
        }),

        /**
         * Creates a mutation endpoint that performs `PUT /{baseEndpoint}/{id}` request to update entity data by ID.
         * Accepts Partial data of entity instance with mandatory id.
         * By default, successful call of update mutation for some entity will patch it's state in all queries where it presented.
         * No further refetch needed. State patch is done my simple merge existing data with updated one.
         *
         * @param {Object} params - The parameters for updating the entity.
         * @param {TEntity['id']} params.id - The ID of the entity to update.
         * @param {Partial<TEntity>} params.data - The partial data of the entity to update.
         * @return {Promise<EntityPartial<TEntity>>} A promise that resolves to the updated entity.
         */
        update: builder.mutation<EntityPartial<TEntity>, EntityPartial<TEntity>>({
          query: (params) => {
            const updatedEntity = createEntityInstance(entityConstructor, params, {
              fromInstancePartial: true,
            }) as TEntity;
            const request = instanceToPlain(updatedEntity);

            return {
              method: 'put',
              url: `${baseEndpoint}/${request.id}`,
              data: request,
            };
          },
          async onQueryStarted(arg, api) {
            await entityApiUtils.handleEntityUpdate(arg, api, { optimistic: false });
          },
          transformResponse: (response: object | undefined, _error, arg) => response
              ? createEntityInstance<TEntity>(entityConstructor, response)
              : (createEntityInstance(entityConstructor, arg, { fromInstancePartial: true }) as TEntity),
        }),

        /**
         * Creates a mutation endpoint that deletes entities by ID using `DELETE/{baseEndpoint}/{id}` request.
         * Accepts entity ID to delete. On success this mutation will remove the entity from all queries where it was presented without refetching them.
         *
         * @param {number} id - The ID of the entity to delete.
         * @return {Promise<void>} A promise that resolves to `undefined` upon successful deletion.
         */
        delete: builder.mutation<void, number>({
          query: (id) => ({
            method: 'delete',
            url: `${baseEndpoint}/${id}`,
          }),
          async onQueryStarted(arg, api) {
            await entityApiUtils.handleEntityDelete(arg, api, { optimistic: false });
          },
        }),
      };

      return omit(endpoints, omitEndpoints || []);
    },
  }) as unknown as EntityApi<TEntity, TSearchRequest, TEntityRequest, TSearchResponse>;

  // Extend api util
  const entityApiUtils = createEntityApiUtils({
    api,
    entityGetRequestConstructor,
    entitySearchRequestConstructor,
  });
  Object.assign(api.util, entityApiUtils);

  // Extend api hooks
  const entityApiHooks = createEntityApiHooks(api);
  Object.assign(api, entityApiHooks);

  // TODO: Get rid of any below and move jsdocs for endpoits to types if possible
  return api as any;
}
